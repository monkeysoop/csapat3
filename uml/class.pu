@startuml ClassDiagram
skinparam classAttributeIconSize 0


package "View" {
    class App {
        -SIDELENGTH : double {const}
        -XLength : int
        -YLength : int
        -Step : int {readonly}
        -_simWindow : SimulationWindow?
        -_replayWindow : ReplayWindow?
        -_startWindow : StartWindow?
        -_viewModel : ViewModel?
        -_ctrlDown : bool
        -_mousePos : Point
        -_rectanle : ImageBrush
        -_ellipses : Ellipse*
        -_robots : Dictonary<Robot, Grid>
        -_targets : Dictonary<Robot, Grid>
        +App()        
        -OnStartup(sender : object, e : StartupEventArgs)
        -ReplayButton_Click(sender : object, e : RoutedEventArgs)
        -SimButton_Click(sender : object, e : RoutedEventArgs)
        -DisposeStartWindow()
        -OpenReplay() : bool
        -OpenSim() : bool
        {static} -DisplayLoading(w : Window)
        -Calculate(c : Canvas)
        -Redraw()
        -DrawGrid(c : Canvas)
        -InitRobots(c : Canvas)
        -DrawElements()
    }
    class SimulationWindow {}
    class ReplayWindow {}
}

interface ICommand {}
interface INotifyPropertyChanged {}

package "ViewModel" {

    ViewModelBase <|-- ViewModel
    ViewModel <|-- SimulationViewModel
    ViewModel <|-- ReplayViewModel

    class DelegateCommand {
        -_execute : Action<object?> {readonly}
        -_canExecute : Predicate<object?>?
        +CanExecuteChanged : EventHandler?
        +Predicate : Predicate<object?>?
        +DelegateCommand(execute : Action<object?>, canExecute : Predicate<object?>?)
        +CanExecute(parameter : object?) : bool
        +Execute(parameter : object?)
        +RaiseCanExecuteChanged()
    }

    class ViewModelBase <<abstract>> {
        +PropertyChanged : PropertyChangedEventHandler?
        +OnPropertyChanged(propertyName : string?)
    }
    class ViewModel {
        #Controller : Controller
        -_zoom : double
        +Width : int {readonly}
        +Height : int {readonly}
        +Zoom : double
        +Robots : Robot* {readonly}
        +Walls : Wall* {readonly}
        +Tick : EventHandler?
        +Loaded : EventHandler?
        #OnLoaded(sender : object?)
        #OnTick(sender : object?)
    }
    class SimulationViewModel {
        - SimController : SimulationController
        +SimulationViewModel(path : string)
    }
    class ReplayViewModel {
        -RepController : ReplayController {readonly}
        +CurrentTime : int
        +ReplayLength : int
        +TimeLabel : string
        +Play : ICommand
        +Pause : ICommand
        +ReplayViewModel(path : string)
    }
}

package "Persistence" {
    class Config {
        -mapFile : string
        -agentFile : string
        -teamSize : int
        -taskFile : string
        -numTasksReveal : int
        -taskAssignmentStrategy : string
        {static} +Load(path : string) : Config
    }

    class Board {
        -Type : string
        +Width : int
        +Height : int
        +Map : IMapObject[,]
        {static} +Load(path : string) : Board
        +this[int x, int y]() : IMapObject {operator}
    }
    
    class LogFile {
        -Events : IEvent*
        -Errors : Error*
        -PlannerTimes : double*
        -previous : DateTime
        +LogError(r1, r2, t : int, msg : string)
        +LogEvent(event : IEvent)
        +Save(path : string)
        {static} +Load(path : string)
    }
}

package "Simulation" {    

    class Controller <<abstract>> {
        #_robots : Robot*
        #_walls : Wall*
        #Timer : Timer
        -_interval : TimeSpan
        #_board : Board
        +Width : int {readonly}
        +Height : int {readonly}
        +Robots : Robot* {readonly}
        +Walls : Wall* {readonly}
        +Tick : EventHandler?
        +Loaded : EventHandler?
        +Controller()
        #OnTick(state : object?) {abstract}
        #OnLoaded(sender : object?)
        #CallTick(sender : object?)
        +ChangeSpeed(speed : double)
    }

    class ReplayController {}

    class SimulationController <<abstract>> {
        -_pathFinder : IAssigner
        +SimulationController(path : string)
        -Load(path : string) {async}
        -LoadWalls()
        #OnTick(state : object?) {override}
    }

    SimulationController "1" *-- "-_assigner" IAssigner

    class PathFinder <<abstract>> {
        ~CalculatePath(board : Board, start : Point, direction : int, end : Point) : bool x Action*
        {static}-TracePath(parents : int[], width : int, start : Point, end : Point) : Action*
        #FindPath(board : Board, start : Point, direction : int, end : Point) : bool x int[] {abstract}
        {static}#ManhatteanDistance(start : Point, end : Point) : int
        {static}#MaxTurnsRequired(start : Point, direction : Point, end : Point) : int
    }

    class DFS {
        #FindPath(board : Board, start : Point, direction : int, end : Point) : bool x int[] {override}
    }

    class BFS {
        #FindPath(board : Board, start : Point, direction : int, end : Point) : bool x int[] {override}
    }

    class Astar {
        {static}-HeapInsert(heap : Step[], length : int, item : Step)
        {static}-HeapRemove(heap : Step[], length : int) : Step
        #FindPath(board : Board, start : Point, direction : int, end : Point) : bool x int[] {override}
    }

    interface IAssigner {
        +Init(type : ControllerType, board : Board, robots : Robot*, packages : Package*)
        +Step()
    }

    Assigner "1" *-- "-_pathFinder" PathFinder
    Assigner "0..*" o-- "-_robots" Robot

    class Assigner {
        -_packages : Queue<Package>
        -Paths : Dictionary<Robot, Path>
        -_board : Board
        +Init(type : ControllerType, board : Board, robots : Robot*, packages : Package*)
        +Step()
        -Assign(r : Robot)
    }

    class Wall {
        +Position : Point {readonly}
        +Wall(x : Point)
    }

    class Robot {
        {static}-IDCounter : int
        +Id : int {readonly}
        +Start : Point {readonly}
        +Position : Point
        +Direction : Direction
        +Task : Package?
        +History : Action* {readonly}
        +Robot(position : Point, direction : Direction)
        +Step(a : Action)
        +AddTask(p : Point?)
    }

    Robot "0..*" o-- "-_history" Action

    class Package {        
        +Postition : Point {readonly}
        +Package(p : Point)
    }

    class Path {
        -_ind : int
        +Target : Point {readonly}
        +IsOver : bool {readonly}
        ~Next() : Action
        ~this[int i] : Action {operator}
    }

    Path "0..*" o-- "-l" Action

    enum Action {
        F, R, C, W, T
    }

    enum Direction {
        north, east, south, west

        {static}+ClockWise() : Direction {extension}
        {static}+CounterClockWise() : Direction {extension}
    }
}


package "Tests" {
    class SimulationTests {}
    class ReplayTests {}
    class BotTests {}
}

App o-- SimulationWindow
App o-- ReplayWindow

ICommand <|-- DelegateCommand
INotifyPropertyChanged <|-- ViewModelBase

ReplayViewModel -- DelegateCommand

SimulationWindow o-- SimulationViewModel
ReplayWindow o-- ReplayViewModel

Controller <|-down- SimulationController
Controller <|-down- ReplayController

IAssigner <|-- Assigner

PathFinder <|-- DFS
PathFinder <|-- BFS
PathFinder <|-- Astar

@enduml